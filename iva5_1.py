# -*- coding: utf-8 -*-
"""iva5_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10GVS1z22X3U0HCbY-AjbZVF4RRRhjSfn
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def extract_frames_and_compare(video_path, bins=50, soft_cut_threshold=(2.2, 2.8)):
    # Open the video file
    cap = cv2.VideoCapture(video_path)

    if not cap.isOpened():
        print("Error: Unable to open video.")
        return

    fps = cap.get(cv2.CAP_PROP_FPS)  # Get frames per second
    frames = []

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        # Convert frame to HSV and equalize V channel
        hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        h, s, v = cv2.split(hsv_frame)
        equalized_v = cv2.equalizeHist(v)
        equalized_hsv = cv2.merge([h, s, equalized_v])

        frames.append(equalized_hsv)

    cap.release()

    # Function to calculate the histogram using np.histogram for each channel
    def calculate_histogram(image, bins=bins):
        h_channel, s_channel, v_channel = cv2.split(image)
        h_hist, _ = np.histogram(h_channel, bins=bins, range=(0, 256))
        s_hist, _ = np.histogram(s_channel, bins=bins, range=(0, 256))
        v_hist, _ = np.histogram(v_channel, bins=bins, range=(0, 256))

        h_hist = h_hist / np.sum(h_hist)
        s_hist = s_hist / np.sum(s_hist)
        v_hist = v_hist / np.sum(v_hist)

        return np.concatenate([h_hist, s_hist, v_hist])

    # Function to calculate intersection score between two histograms
    def histogram_intersection(hist1, hist2):
        return np.sum(np.minimum(hist1, hist2))

    # Compute histograms for adjacent frames and compare them
    scores = []
    histograms = [calculate_histogram(frame) for frame in frames]

    for i in range(len(histograms) - 1):
        score = histogram_intersection(histograms[i], histograms[i + 1])
        scores.append(score)
        print(f"Intersection score between frame {i} and frame {i + 1}: {score:.4f}")

    # Function to display two frames side by side with motion highlighted and annotation
    def show_frames_with_motion(frame1, frame2, motion_mask, title1="Frame 1", title2="Frame 2", timestamp1=None, timestamp2=None):
        rgb_frame1 = cv2.cvtColor(frame1, cv2.COLOR_HSV2RGB)  # Convert back to RGB for display
        rgb_frame2 = cv2.cvtColor(frame2, cv2.COLOR_HSV2RGB)  # Convert back to RGB for display

        # Highlight motion in red in both frames
        frame1_with_motion = rgb_frame1.copy()
        frame1_with_motion[motion_mask > 50] = [255, 0, 0]  # Highlight moving regions in red

        frame2_with_motion = rgb_frame2.copy()
        frame2_with_motion[motion_mask > 50] = [255, 0, 0]  # Highlight moving regions in red

        # Plot both frames side by side
        fig, axs = plt.subplots(1, 2, figsize=(12, 6))

        axs[0].imshow(frame1_with_motion)
        axs[0].set_title(title1 + (f" | Timestamp: {timestamp1:.2f}s" if timestamp1 else ""))
        axs[0].axis('off')

        axs[1].imshow(frame2_with_motion)
        axs[1].set_title(title2 + (f" | Timestamp: {timestamp2:.2f}s" if timestamp2 else ""))
        axs[1].axis('off')

        plt.show()

    # Identify and display the frames with scores below the thresholds and motion detection
    j, k = 1, 1  # Track soft and hard cuts
    prev_frame = frames[0]
    for i, score in enumerate(scores):
        # Calculate the absolute difference between consecutive frames for motion detection
        frame_diff = cv2.absdiff(frames[i], prev_frame)
        motion_mask = cv2.cvtColor(frame_diff, cv2.COLOR_BGR2GRAY)
        timestamp1 = i / fps  # Timestamp for frame i
        timestamp2 = (i + 1) / fps  # Timestamp for frame i+1
        if score < soft_cut_threshold[1]:  # Scene cut detected
            if score > soft_cut_threshold[0]:  # Soft cut
                print(f"Scene_Cut(SOFT): {j}")
                print(f"Frame {i} and Frame {i+1} have an intersection score: {score:.4f}")
                show_frames_with_motion(frames[i], frames[i + 1], motion_mask,
                                        title1=f"Soft Scene Cut {j} - Frame {i}",
                                        title2=f"Soft Scene Cut {j} - Frame {i + 1}",
                                        timestamp1=timestamp1, timestamp2=timestamp2)
                j += 1
            else:  # Hard cut
                print(f"Scene_Cut(HARD): {k}")
                print(f"Frame {i} and Frame {i+1} have an intersection score: {score:.4f}")
                show_frames_with_motion(frames[i], frames[i + 1], motion_mask,
                                        title1=f"Hard Scene Cut {k} - Frame {i}",
                                        title2=f"Hard Scene Cut {k} - Frame {i + 1}",
                                        timestamp1=timestamp1, timestamp2=timestamp2)
                k += 1
        prev_frame = frames[i]  # Update the previous frame for the next iteration
    return frames, scores
# Example usage
video_path = "/content/sample_data/4_vid_com.mp4"
frames, scores = extract_frames_and_compare(video_path)

